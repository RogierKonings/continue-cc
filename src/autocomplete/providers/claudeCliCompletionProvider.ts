import * as vscode from 'vscode';
import type { ClaudeCliClient } from '../../api/claudeCliClient';
import type { ClaudeCliAuthService } from '../../auth/claudeCliAuthService';

export class ClaudeCliCompletionProvider implements vscode.CompletionItemProvider {
  private cliClient: ClaudeCliClient;

  constructor(
    private readonly authService: ClaudeCliAuthService,
    private readonly context: vscode.ExtensionContext
  ) {
    this.cliClient = authService.getCliClient();
  }

  async provideCompletionItems(
    document: vscode.TextDocument,
    position: vscode.Position,
    token: vscode.CancellationToken,
    context: vscode.CompletionContext
  ): Promise<vscode.CompletionItem[] | undefined> {
    try {
      // Check if authenticated
      const isAuthenticated = await this.authService.isAuthenticated();
      if (!isAuthenticated) {
        return undefined;
      }

      // Get the text around the cursor
      const range = new vscode.Range(
        new vscode.Position(Math.max(0, position.line - 10), 0),
        new vscode.Position(position.line + 5, 0)
      );
      const contextCode = document.getText(range);

      // Get the current line and cursor position
      const currentLine = document.lineAt(position);
      const textBeforeCursor = currentLine.text.substring(0, position.character);
      const textAfterCursor = currentLine.text.substring(position.character);

      // Build the code to complete
      const beforeContext = document.getText(
        new vscode.Range(new vscode.Position(Math.max(0, position.line - 10), 0), position)
      );
      const afterContext = document.getText(
        new vscode.Range(
          position,
          new vscode.Position(Math.min(document.lineCount - 1, position.line + 5), 0)
        )
      );

      const fullCode = beforeContext + '<CURSOR>' + afterContext;

      // Get language
      const language = document.languageId;
      const filename = document.fileName;

      // Make completion request
      const response = await this.cliClient.getCodeCompletion({
        code: fullCode,
        language,
        filename,
        maxTokens: 150,
      });

      if (!response.text.trim()) {
        return undefined;
      }

      // Create completion item
      const completionItem = new vscode.CompletionItem(
        response.text.trim(),
        vscode.CompletionItemKind.Text
      );

      completionItem.insertText = response.text.trim();
      completionItem.detail = 'Claude Code';
      completionItem.documentation = new vscode.MarkdownString(
        `Generated by Claude Code\n\nTokens: ${response.usage.totalTokens}`
      );

      // Set sort text to prioritize Claude completions
      completionItem.sortText = '0-claude';

      return [completionItem];
    } catch (error) {
      console.error('Claude completion error:', error);
      return undefined;
    }
  }

  async provideInlineCompletionItems(
    document: vscode.TextDocument,
    position: vscode.Position,
    context: vscode.InlineCompletionContext,
    token: vscode.CancellationToken
  ): Promise<vscode.InlineCompletionItem[] | undefined> {
    try {
      // Check if authenticated
      const isAuthenticated = await this.authService.isAuthenticated();
      if (!isAuthenticated) {
        return undefined;
      }

      // Get context around the cursor
      const range = new vscode.Range(
        new vscode.Position(Math.max(0, position.line - 20), 0),
        new vscode.Position(Math.min(document.lineCount - 1, position.line + 10), 0)
      );
      const contextCode = document.getText(range);

      // Calculate cursor position in the context
      const beforeRange = new vscode.Range(
        new vscode.Position(Math.max(0, position.line - 20), 0),
        position
      );
      const beforeText = document.getText(beforeRange);
      const cursorPosition = beforeText.length;

      // Get completion
      const response = await this.cliClient.getCodeCompletion({
        code: contextCode,
        language: document.languageId,
        filename: document.fileName,
        cursorPosition,
        maxTokens: 200,
      });

      if (!response.text.trim()) {
        return undefined;
      }

      // Create inline completion
      const inlineCompletion = new vscode.InlineCompletionItem(
        response.text.trim(),
        new vscode.Range(position, position)
      );

      inlineCompletion.command = {
        command: 'continue-cc.trackInlineCompletion',
        title: 'Track Completion',
        arguments: [response.text.trim()],
      };

      return [inlineCompletion];
    } catch (error) {
      console.error('Claude inline completion error:', error);
      return undefined;
    }
  }
}
